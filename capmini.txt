
aprox.inicial = function(y,x,condi=T,equal=T,g1,nuentrada){

# condi=T, temos que eta é conhecido, portanto estima somente omega
# condi=F, temos que eta é desconhecido, portanto, estima eta e omega



  print("aprox.inicial")
  
if(p==1){modelt<-smsn.mix(y, nu=1, mu =NULL, shape = NULL, pii = NULL, g = g1, get.init = TRUE, criteria = FALSE,                    group = FALSE, family =  "t", error = 0.0001, iter.max = 100, calc.im=FALSE,                    obs.prob= FALSE, kmeans.param = NULL)  }else{
 
  #### chute inicial para mu e Sigma  via t
  modelt<-smsn.mmix(y, nu=100, mu =NULL, Sigma = NULL, shape = NULL, pii = NULL, g = g1, get.init = TRUE, criteria = FALSE,
                      group = FALSE, family =  "t", error = 0.0001, iter.max = 100, uni.Gama = T, calc.im=FALSE,
                      obs.prob= FALSE, kmeans.param = NULL)

}
if(p==1){Sigma=var(x)}else{
Sigma=modelt$Sigma[[1]]}

 svm_model <- svm(y, kernel = "polynomial",degree=1,gamma = 0.7)
# Display the model summary  
predictions <- predict(svm_model, y)
pii<-sort(rev(table(predictions)/n))

#pii=modelt$pii

alpha=matrix(rep(1,p),p,1)
beta=matrix(rep(1,p),p,1)
if (g1 >= 3) {
kmeans_result <- kmeans(y, centers = 3)    # Get the cluster labels generated by K-means  cluster_labels <- kmeans_result$cluster    # Step 2: Train the SVM model using the clustered labels  svm_model <- svm(y, as.factor(cluster_labels), type = "C-classification"                   , kernel = "polynomial",degree=1,gamma = 0.7)    # Step 3: Use the trained SVM model to classify new data  # Example of predicting for the same data (you can replace with new data)  predicted_clusters <- predict(svm_model, y)  #
  pii <-sort(table(predicted_clusters)/n) #sort(modelt$pii)
}
if (condi==TRUE){

omega=list()
nu.ini=list()

 for (j in 1:g1){
omega[[j]]=sqrt((modelt$nu))  # como valor inicial estamos considerando omegas iguais para os grupos
nu.ini[[j]] <-c(nuentrada[[j]][1],omega[[j]],omega[[j]])  # considerando a reparametrização psi=gamma
}

if (equal==T){ resini=EM(y, x,alpha,beta, Sigma, nu=nu.ini, pii,g=g1,iter.max=100,error=0.0001,condi=T,equal=T)}else{ resini=EM(y, x,alpha,beta, Sigma, nu=nu.ini, pii,g=g1,iter.max=100,error=0.0001,condi=T,equal=F)}

}


if (condi==F){

tal <- matrix(0, n, g1)
S1 <- matrix(0, n, g1)
S2<- matrix(0, n, g1)
S4 <- matrix(0, n, g1)

omega=list()
nu.ini=list()
etaini=c(0.5,-0.5) ## chute considerando BS depois iremos atualizar abaixo (duas atualizações)

for (j in 1:g1){
         eta0 = etaini[[j]]
          omega[[j]]=sqrt((modelt$nu))  # como valor inicial estamos considerando omegas iguais para os grupos
          nu.ini[[j]]=c(eta0,omega[[j]],omega[[j]]) # considerando a reparametrização psi=gamma
}

for (j in 1:g1){

 ### E-step

         eta0 = etaini[[j]]
          dj <- mahalanobis(y, mu[[j]], Sigma[[j]])
          qy = sqrt(omega[[j]] + dj)      
          aux1 = qy*(omega[[j]])^(1/2)      
          ct1 = matrix((omega[[j]]^(1/2)/qy)^(eta0-p/2)*(1/(2*besselK(aux1, eta0-p/2))),n,1)      
          ct2 = matrix((omega[[j]]^(1/2)/qy)^(eta0-(p/2)-1)*(1/(2*besselK(aux1, eta0-(p/2)-1))),n,1)
          ct4 = matrix((omega[[j]]^(1/2)/qy)^(eta0-(p/2)+1)*(1/(2*besselK(aux1, eta0-(p/2)+1))),n,1)        

         u = matrix(0,n,1)      # valor esperado de u-1
         v = matrix(0,n,1)     # valor esperado de u
         s = matrix(0,n,1)     # valor esperado de log(u)
         derivada=matrix(0,n,1)

          u = (ct1/ct2)
          v = (ct1/ct4)

for (hh in 1:n){      
         
          phi4=eta0-p/2
          f<-function(phi4){

                                    besselK(aux1[hh], phi4)

                                   }

         derivada[hh]<-grad(f, phi4)
         s[hh]=log(qy[hh]/sqrt(omega[[j]]))+  ( (1/besselK(aux1[hh],eta0-p/2))*derivada[hh] )

                        }

          nu0=c(eta0,omega[[j]])
          d1 <- dmv_SNGH(y, mu[[j]], Sigma[[j]], nu0)
          if(length(which(d1 == 0)) > 0) d1[which(d1 == 0)] <- .Machine$double.xmin

         
          d2 <-  d.mixedmvSNGH(y, pii, mu, Sigma, nu=nu.ini)
          if(length(which(d2 == 0)) > 0) d2[which(d2 == 0)] <- .Machine$double.xmin


          tal[,j] <- d1*pii[j] / d2
          S1[,j] <- tal[,j]*u   
          S2[,j] <- tal[,j]*s
          S4[,j] <- tal[,j]*v

}

nu1.ini=list()

for (j in 1:g1){
eta1=nuentrada[[j]][1]
omega1=nuentrada[[j]][2]
nu1=c(eta1,omega1)
nu1.ini[[j]] <- optim(nu1, method = "L-BFGS-B", maxfmulti, lower =c(-1,0.01), upper =c(1,3), tal=tal[,j],S1=S1[,j],S4=S4[,j],S2=S2[,j],hessian=TRUE)$par
                         }

resini=EM(y, x, alpha,beta, Sigma, nu=nu1.ini, pii,g=g1,iter.max=100,error=0.0001,condi=F,equal=F)

}


    Sigmaini=piini=nuini=alphaini=betaini=list()


    if(class(resini) != "try-error"){
    Sigmaini = resini$Sigma
     nuini = resini$nu
      piini=resini$pii
      alphaini=resini$alpha
      betaini=resini$beta
      result = list(Sigma = Sigmaini, nu= nuini,pii=piini, alpha=alphaini, beta=betaini)
      return(result)
    }else{
      return("NULL")
    }
  #} else{
  #  return("NULL")
  #}
}


maxfmulti<-function(nu,tal,S1,S4,S2){
   eta<-nu[1]
   omega<-nu[2]
   soma<-(eta-1)*mean(S2)-log(besselK(omega, eta))*mean(tal)-0.5*omega*(mean(S1)+mean(S4))
    return(-soma)
}

grid_search_log_likelihood_nu2 <- function(y, x, alpha, beta, Sigma, nu, pii, grid_size = 0.5) {
  # Initialize the best log-likelihood and parameters
  best_lk <- -Inf
  best_nu2 <- NULL
  
  # Extract the fixed nu1 value (the first component stays unchanged)
  nu1_fixed <- nu[[1]]
  
  # Define the search range for nu2
  nu2_range <- seq(nu[[2]][2] - grid_size, nu[[2]][2] + grid_size, by = 0.1)
  
  # Loop through the range for nu2
  for (nu2_val in nu2_range) {
    # Update nu2 values (nu1 stays fixed)
    nu[[2]] <- c(nu[[2]][1], nu2_val)
    
    # Calculate the log-likelihood using the provided function
    log_likelihood <- sum(log(d.mixedmvSNGHCAPM(y, x, pii, alpha, beta, Sigma, nu)))
    
    # Check if this is the best log-likelihood found
    if (log_likelihood > best_lk) {
      best_lk <- log_likelihood
      best_nu2 <- nu2_val
    }
  }
  
  # Return the best nu2 and the maximum log-likelihood
  return(list(best_nu2 = best_nu2, max_lk = best_lk))
}


grid_search_log_likelihood_pii <- function(y, x, alpha, beta, Sigma, nu, pii) {
  # Initialize the best log-likelihood and parameters
  best_lk <- -Inf
  best_pii <- NULL
  
  pii=sort(pii)
  # Define the search range for pii
  pii_range <- seq(pii[1], 1, by = 0.01)
  
  # Loop through the range for pii
  for (pii_val in pii_range) {
    
    pii <- sort(c(pii_val,1-pii_val))
    
    # Calculate the log-likelihood using the provided function
    log_likelihood <- sum(log(d.mixedmvSNGHCAPM(y, x, pii, alpha, beta, Sigma, nu)))
    
    # Check if this is the best log-likelihood found
    if (log_likelihood > best_lk) {
      best_lk <- log_likelihood
      best_pii <- pii_val
    }
  }
  
  # Return the best pii and the maximum log-likelihood
  return(list(best_pii = best_pii, max_lk = best_lk))
}
grid_search_log_likelihood <- function(y, x, alpha, beta, Sigma, nu, pii, grid_size = 0.5) {
  # Initialize the best log-likelihood and parameters
  best_lk <- -Inf
  best_nu1 <- NULL
  best_nu2 <- NULL
  
  # Extract fixed nu values (the first components)
  nu1_fixed <- nu[[1]][1]
  nu2_fixed <- nu[[2]][1]
  
  # Define the search ranges around the initial values
  nu1_range <- seq(resini$nu[[1]][2] - grid_size, resini$nu[[1]][2]+ grid_size, by = 0.1)
  nu2_range <- seq(resini$nu[[2]][2] - grid_size, resini$nu[[2]][2] + grid_size, by = 0.1)
  
  # Loop through the ranges for nu1 and nu2
  for (nu1_val in nu1_range) {
    for (nu2_val in nu2_range) {
      # Update nu values with the fixed first components
      nu[[1]] <- c(nu1_fixed, nu1_val)
      nu[[2]] <- c(nu2_fixed, nu2_val)
      
      # Calculate the log-likelihood using the provided function
      log_likelihood <- sum(log(d.mixedmvSNGHCAPM(y, x, pii, alpha, beta, Sigma, nu)))
      
      # Check if this is the best log-likelihood found
      if (log_likelihood > best_lk) {
        best_lk <- log_likelihood
        best_nu1 <- nu1_val
        best_nu2 <- nu2_val
      }
    }
  }
  
  # Return the best parameters and the maximum log-likelihood
  return(list(best_nu1 = best_nu1, best_nu2 = best_nu2, max_lk = best_lk))
}

grid_search_log_likelihood_nu2 <- function(y, x, alpha, beta, Sigma, nu, pii, grid_size = 0.5) {
  # Initialize the best log-likelihood and parameters
  best_lk <- -Inf
  best_nu2 <- NULL
  
  # Extract the fixed nu1 value (the first component stays unchanged)
  nu1_fixed <- nu[[1]]
  
  # Define the search range for nu2
  nu2_range <- seq(resini$nu[[2]][2] - grid_size, resini$nu[[2]][2] + grid_size, by = 0.1)
  
  # Loop through the range for nu2
  for (nu2_val in nu2_range) {
    # Update nu2 values (nu1 stays fixed)
    nu[[2]] <- c(nu[[2]][1], nu2_val)
    
    # Calculate the log-likelihood using the provided function
    log_likelihood <- sum(log(d.mixedmvSNGHCAPM(y, x, pii, alpha, beta, Sigma, nu)))
    
    # Check if this is the best log-likelihood found
    if (log_likelihood > best_lk) {
      best_lk <- log_likelihood
      best_nu2 <- nu2_val
    }
  }
  
  # Return the best nu2 and the maximum log-likelihood
  return(list(best_nu2 = best_nu2, max_lk = best_lk))
}
grid_search_log_likelihood3 <- function(y, x, alpha, beta, Sigma, nu, pii, grid_size = 0.5) {
  # Initialize the best log-likelihood and parameters
  best_lk <- -Inf
  best_nu1 <- NULL
  best_nu2 <- NULL
  best_nu3 <- NULL
  
  # Extract fixed nu values (the first components)
  nu1_fixed <- nu[[1]][1]
  nu2_fixed <- nu[[2]][1]
  nu3_fixed <- nu[[3]][1]
  
  # Define the search ranges around the initial values
  nu1_range <- seq(nu[[1]][2] - grid_size, nu[[1]][2] + grid_size, by = 0.1)
  nu2_range <- seq(nu[[2]][2] - grid_size, nu[[2]][2] + grid_size, by = 0.1)
  nu3_range <- seq(nu[[3]][2] , nu[[3]][2] + grid_size+1, by = 0.1)
  
  # Loop through the ranges for nu1, nu2, and nu3
  for (nu1_val in nu1_range) {
    for (nu2_val in nu2_range) {
      for (nu3_val in nu3_range) {
        # Update nu values with the fixed first components
        nu[[1]] <- c(nu1_fixed, nu1_val)
        nu[[2]] <- c(nu2_fixed, nu2_val)
        nu[[3]] <- c(nu3_fixed, nu3_val)
        
        # Calculate the log-likelihood using the provided function
        log_likelihood <- sum(log(d.mixedmvSNGHCAPM(y, x, pii, alpha, beta, Sigma, nu)))
        
        # Check if this is the best log-likelihood found
        if (log_likelihood > best_lk) {
          best_lk <- log_likelihood
          best_nu1 <- nu1_val
          best_nu2 <- nu2_val
          best_nu3 <- nu3_val
        }
      }
    }
  }
  
  # Return the best parameters and the maximum log-likelihood
  return(list(best_nu1 = best_nu1, best_nu2 = best_nu2, best_nu3 = best_nu3, max_lk = best_lk))
}
grid_search_log_likelihood3nu3fixed <- function(y, x, alpha, beta, Sigma, nu, pii, grid_size = 0.5) {
  # Initialize the best log-likelihood and parameters
  best_lk <- -Inf
  best_nu3 <- NULL
  
  # Extract fixed nu values (the first components)
  nu1_fixed <- nu[[1]]  # Fix nu1
  nu2_fixed <- nu[[2]]  # Fix nu2
  
  # Define the search range for nu3 around the initial values
  nu3_range <- seq(nu[[3]][2], nu[[3]][2] + grid_size, by = 0.1)
  
  # Loop through the range for nu3
  for (nu3_val in nu3_range) {
    # Update nu3 value with the fixed first component
    nu[[3]] <- c(nu[[3]][1], nu3_val)
    
    # Calculate the log-likelihood using the provided function
    log_likelihood <- sum(log(d.mixedmvSNGHCAPM(y, x, pii, alpha, beta, Sigma, nu)))
    
    # Check if this is the best log-likelihood found
    if (log_likelihood > best_lk) {
      best_lk <- log_likelihood
      best_nu3 <- nu3_val
    }
  }
  
  # Return the best nu3 and the maximum log-likelihood
  return(list(best_nu3 = best_nu3, max_lk = best_lk))
}
grid_search_log_likelihood3nu2fixed <- function(y, x, alpha, beta, Sigma, nu, pii, grid_size = 0.5) {
  # Initialize the best log-likelihood and parameters
  best_lk <- -Inf
  best_nu2 <- NULL
  
  # Extract fixed nu values (nu1 and nu3 stay fixed)
  nu1_fixed <- nu[[1]]  # Fix nu1
  nu3_fixed <- nu[[3]]  # Fix nu3
  
  # Define the search range for nu2 around the initial values
  nu2_range <- seq(nu[[2]][2] - grid_size, nu[[2]][2] + grid_size, by = 0.1)
  
  # Loop through the range for nu2
  for (nu2_val in nu2_range) {
    # Update nu2 value with the fixed first component
    nu[[2]] <- c(nu[[2]][1], nu2_val)
    
    # Calculate the log-likelihood using the provided function
    log_likelihood <- sum(log(d.mixedmvSNGHCAPM(y, x, pii, alpha, beta, Sigma, nu)))
    
    # Check if this is the best log-likelihood found
    if (log_likelihood > best_lk) {
      best_lk <- log_likelihood
      best_nu2 <- nu2_val
    }
  }
  
  # Return the best nu2 and the maximum log-likelihood
  return(list(best_nu2 = best_nu2, max_lk = best_lk))
}
grid_search_log_likelihood3nu1fixed <- function(y, x, alpha, beta, Sigma, nu, pii, grid_size = 0.5) {
  # Initialize the best log-likelihood and parameters
  best_lk <- -Inf
  best_nu1 <- NULL
  
  # Extract fixed nu values (nu2 and nu3 stay fixed)
  nu2_fixed <- nu[[2]]  # Fix nu2
  nu3_fixed <- nu[[3]]  # Fix nu3
  
  # Define the search range for nu1 around the initial values
  nu1_range <- seq(nu[[1]][2] - grid_size, nu[[1]][2] + grid_size, by = 0.1)
  
  # Loop through the range for nu1
  for (nu1_val in nu1_range) {
    # Update nu1 value with the fixed first component
    nu[[1]] <- c(nu[[1]][1], nu1_val)
    
    # Calculate the log-likelihood using the provided function
    log_likelihood <- sum(log(d.mixedmvSNGHCAPM(y, x, pii, alpha, beta, Sigma, nu)))
    
    # Check if this is the best log-likelihood found
    if (log_likelihood > best_lk) {
      best_lk <- log_likelihood
      best_nu1 <- nu1_val
    }
  }
  
  # Return the best nu1 and the maximum log-likelihood
  return(list(best_nu1 = best_nu1, max_lk = best_lk))
}
grid_search_log_likelihood3nu2nu3fixed <- function(y, x, alpha, beta, Sigma, nu, pii, grid_size = 0.5) {
  # Initialize the best log-likelihood and parameters
  best_lk <- -Inf
  best_nu2 <- NULL
  best_nu3 <- NULL
  
  # Extract fixed nu value (nu1 stays fixed)
  nu1_fixed <- nu[[1]]  # Fix nu1
  
  # Define the search ranges for nu2 and nu3 around the initial values
  nu2_range <- seq(nu[[2]][2] - grid_size, nu[[2]][2] + grid_size, by = 0.1)
  nu3_range <- seq(nu[[3]][2] - grid_size, nu[[3]][2] + grid_size, by = 0.1)
  
  # Loop through the ranges for nu2 and nu3
  for (nu2_val in nu2_range) {
    for (nu3_val in nu3_range) {
      # Update nu2 and nu3 values with the fixed first components
      nu[[2]] <- c(nu[[2]][1], nu2_val)
      nu[[3]] <- c(nu[[3]][1], nu3_val)
      
      # Calculate the log-likelihood using the provided function
      log_likelihood <- sum(log(d.mixedmvSNGHCAPM(y, x, pii, alpha, beta, Sigma, nu)))
      
      # Check if this is the best log-likelihood found
      if (log_likelihood > best_lk) {
        best_lk <- log_likelihood
        best_nu2 <- nu2_val
        best_nu3 <- nu3_val
      }
    }
  }
  
  # Return the best nu2, nu3, and the maximum log-likelihood
  return(list(best_nu2 = best_nu2, best_nu3 = best_nu3, max_lk = best_lk))
}
grid_search_log_likelihood3nu1nu3fixed <- function(y, x, alpha, beta, Sigma, nu, pii, grid_size = 0.5) {
  # Initialize the best log-likelihood and parameters
  best_lk <- -Inf
  best_nu1 <- NULL
  best_nu3 <- NULL
  
  # Extract fixed nu value (nu2 stays fixed)
  nu2_fixed <- nu[[2]]  # Fix nu2
  
  # Define the search ranges for nu1 and nu3 around the initial values
  nu1_range <- seq(nu[[1]][2] - grid_size, nu[[1]][2] + grid_size, by = 0.1)
  nu3_range <- seq(nu[[3]][2]-1 , nu[[3]][2] + grid_size, by = 0.1)
  
  # Loop through the ranges for nu1 and nu3
  for (nu1_val in nu1_range) {
    for (nu3_val in nu3_range) {
      # Update nu1 and nu3 values with the fixed first components
      nu[[1]] <- c(nu[[1]][1], nu1_val)
      nu[[3]] <- c(nu[[3]][1], nu3_val)
      
      # Calculate the log-likelihood using the provided function
      log_likelihood <- sum(log(d.mixedmvSNGHCAPM(y, x, pii, alpha, beta, Sigma, nu)))
      
      # Check if this is the best log-likelihood found
      if (log_likelihood > best_lk) {
        best_lk <- log_likelihood
        best_nu1 <- nu1_val
        best_nu3 <- nu3_val
      }
    }
  }
  
  # Return the best nu1, nu3, and the maximum log-likelihood
  return(list(best_nu1 = best_nu1, best_nu3 = best_nu3, max_lk = best_lk))
}


grid_search_log_likelihood3nu1nu2fixed <- function(y, x, alpha, beta, Sigma, nu, pii, grid_size = 0.5) {
  # Initialize the best log-likelihood and parameters
  best_lk <- -Inf
  best_nu1 <- NULL
  best_nu2 <- NULL
  
  # Extract the fixed nu3 value (nu3 stays fixed)
  nu3_fixed <- nu[[3]]  # Fix nu3
  
  # Define the search ranges for nu1 and nu2 around the initial values
  nu1_range <- seq(nu[[1]][2] - grid_size, nu[[1]][2] + grid_size, by = 0.1)
  nu2_range <- seq(nu[[2]][2] - grid_size, nu[[2]][2] + grid_size, by = 0.1)
  
  # Loop through the ranges for nu1 and nu2
  for (nu1_val in nu1_range) {
    for (nu2_val in nu2_range) {
      # Update nu1 and nu2 values with the fixed first components
      nu[[1]] <- c(nu[[1]][1], nu1_val)
      nu[[2]] <- c(nu[[2]][1], nu2_val)
      
      # Calculate the log-likelihood using the provided function
      log_likelihood <- sum(log(d.mixedmvSNGHCAPM(y, x, pii, alpha, beta, Sigma, nu)))
      
      # Check if this is the best log-likelihood found
      if (log_likelihood > best_lk) {
        best_lk <- log_likelihood
        best_nu1 <- nu1_val
        best_nu2 <- nu2_val
      }
    }
  }
  
  # Return the best nu1, nu2, and the maximum log-likelihood
  return(list(best_nu1 = best_nu1, best_nu2 = best_nu2, max_lk = best_lk))
}
grid_search_log_likelihoodeta <- function(y, x, alpha, beta, Sigma, nu, pii, grid_size = 0.5) {
  # Initialize the best log-likelihood and parameters
  best_lk <- -Inf
  best_nu1 <- NULL
  best_nu2 <- NULL
  
  # Extract values to be treated as fixed (second components)
  nu1_val <- nu[[1]][2]
  nu2_val <- nu[[2]][2]
  
  # Define the search ranges around the initial values for nu1_fixed and nu2_fixed
  nu1_range <- seq(resini$nu[[1]][1] - grid_size, resini$nu[[1]][1] + grid_size, by = 0.1)
  nu2_range <- seq(resini$nu[[2]][1] - grid_size, resini$nu[[2]][1] + grid_size, by = 0.1)
  
  # Loop through the ranges for nu1_fixed and nu2_fixed
  for (nu1_fixed in nu1_range) {
    for (nu2_fixed in nu2_range) {
      # Update nu values with the fixed second components
      nu[[1]] <- c(nu1_fixed, nu1_val)
      nu[[2]] <- c(nu2_fixed, nu2_val)
      
      # Calculate the log-likelihood using the provided function
      log_likelihood <- sum(log(d.mixedmvSNGHCAPM(y, x, pii, alpha, beta, Sigma, nu)))
      
      # Check if this is the best log-likelihood found
      if (log_likelihood > best_lk) {
        best_lk <- log_likelihood
        best_nu1 <- nu1_fixed
        best_nu2 <- nu2_fixed
      }
    }
  }
  
  # Return the best parameters and the maximum log-likelihood
  return(list(best_nu1 = best_nu1, best_nu2 = best_nu2, max_lk = best_lk))
}

