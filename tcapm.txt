################################################################ Packages##############################################################library(numDeriv)require(mvtnorm)#############################gera############################rMN <-  function(n,mu,Sigma){    if(is.null(n))      stop("sample size must be specified")    if(is.null(mu))      stop("mu must be specified")    if(is.null(Sigma))      stop("Sigma must be specified")    if(is.vector(Sigma)) Sigma=matrix(Sigma)    if(round(n)!=n | n<=0)      stop("sample size must be a positive integer")          if(!is.matrix(mu)) mu<-matrix(mu, ncol=length(mu),nrow=1)    if (!isSymmetric(Sigma))      stop("Sigma is not symmetric")    if (min(eigen(Sigma)$values)<=0)      stop("Sigma is not a positive-definite matrix")    if (ncol(Sigma) != ncol(mu))      stop("The dimension of mu does not agree with the dimension of Sigma")    p<-ncol(Sigma)    y<-matrix(0,n,p)    for(i in 1:n){      y[i,]=as.vector(mu)+MASS::mvrnorm(1,rep(0,p),Sigma)    }     return(y)   }rMSL <-  function(n, mu,Sigma, nu=1){    if(is.null(n))      stop("sample size must be specified")    if(is.null(mu))      stop("mu must be specified")    if(is.null(Sigma))      stop("Sigma must be specified")    if(is.vector(Sigma)) Sigma=matrix(Sigma)    if(round(n)!=n | n<=0)      stop("sample size must be a positive integer")              if(!is.matrix(mu)) mu<-matrix(mu, ncol=length(mu),nrow=1)    if (!isSymmetric(Sigma))      stop("Sigma is not symmetric")    if (min(eigen(Sigma)$values)<=0)      stop("Sigma is not a positive-definite matrix")    if (ncol(Sigma) != ncol(mu))      stop("The dimension of mu does not agree with the dimension of Sigma")    if(nu<=0)      stop("nu must be positive")    p<-ncol(Sigma)    y<-matrix(0,n,p)    for(i in 1:n){      u<-rbeta(1,nu,1)      y[i,]=as.vector(mu)+MASS::mvrnorm(1,rep(0,p),Sigma/u)    }     return(y)  }rMT <-  function(n, mu,Sigma, nu=1){    if(is.null(n))      stop("sample size must be specified")    if(is.null(mu))      stop("mu must be specified")    if(is.null(Sigma))      stop("Sigma must be specified")    if(is.vector(Sigma)) Sigma=matrix(Sigma)      if(round(n)!=n | n<=0)      stop("sample size must be a positive integer")          if(!is.matrix(mu)) mu<-matrix(mu, ncol=length(mu),nrow=1)    if (!isSymmetric(Sigma))      stop("Sigma is not symmetric")    if (min(eigen(Sigma)$values)<=0)      stop("Sigma is not a positive-definite matrix")    if (ncol(Sigma) != ncol(mu))      stop("The dimension of mu does not agree with the dimension of Sigma")    if(nu<0)      stop("nu must be positive")    p<-ncol(Sigma)    y<-matrix(0,n,p)    for(i in 1:n){      u=rgamma(1,nu/2,nu/2)      y[i,]=as.vector(mu[i,])+MASS::mvrnorm(1,rep(0,p),Sigma/u)    }     return(y)   }rMCN <-  function(n, mu,Sigma, nu=0.5, gamma=0.5){    if(is.null(n))      stop("sample size must be specified")    if(is.null(mu))      stop("mu must be specified")    if(is.null(Sigma))      stop("Sigma must be specified")    if(is.vector(Sigma)) Sigma=matrix(Sigma)    if(round(n)!=n | n<=0)      stop("sample size must be a positive integer")          if(!is.matrix(mu)) mu<-matrix(mu, ncol=length(mu),nrow=1)    if (!isSymmetric(Sigma))      stop("Sigma is not symmetric")    if (min(eigen(Sigma)$values)<=0)      stop("Sigma is not a positive-definite matrix")    if (ncol(Sigma) != ncol(mu))      stop("The dimension of mu does not agree with the dimension of Sigma")    if (nu<0 | nu>1)      stop("nu must be between 0 and 1")    if (gamma<0 | gamma>1)      stop("gamma must be between 0 and 1")    p<-ncol(Sigma)    y<-matrix(0,n,p)    for(i in 1:n){      uu<-rbinom(1,1,nu)      u<-gamma*uu+1-uu      y[i,]=as.vector(mu)+MASS::mvrnorm(1,rep(0,p),Sigma/u)    }     return(y)  }matrix.sqrt <- function(A) {  sva <- svd(A)  if (min(sva$d)>=0)    Asqrt <- t(sva$v %*% (t(sva$u) * sqrt(sva$d)))  else    stop("Matrix square root is not defined")  return(Asqrt)}gerahelton<-function(n,p,mu,Sigma,nu, dist){    t=matrix(0,n,p)    if (dist == "Normal"){z<- rMN(n,mu=mu,Sigma)}  if (dist == "Student"){z<- rMT(n,mu=mu,Sigma,nu)}  if (dist == "Slash"){z<- rMSL(n,mu=mu,Sigma,nu)}  if (dist == "Cont"){nu1=nu[1]  gama=nu[2]  z<- rMCN (n,mu=mu,Sigma,nu=nu1, gamma=gama)}        return(z)  }################################################################ log-likelihood##############################################################fp1<-function(a,b){  cdf<-pgamma(1, shape=a, scale = 1/b)  return(cdf)}verohelton<-function(t,alpha,beta,Sigma,nu,dist){    mm=dim(t)[1]  p=dim(t)[2]    eta=matrix(0,mm,p)  epsilon=matrix(0,mm,p)  at=matrix(0,mm,p)  Atparte=matrix(0,mm,p)  vero1=matrix(0,mm,1)  dt=matrix(0,mm,1)  funk=matrix(0,mm,1)      #for (j in 1:p) {  #  epsilon[,j]=sqrt(t[,j]/beta[j])-sqrt(beta[j]/t[,j])  #  at[,j]=epsilon[,j]/alpha[j]  #  Atparte[,j]= (t[,j]+beta[j])/(2*alpha[j]*sqrt(beta[j])*sqrt(t[,j]^3))  #}     #At=apply(Atparte,1,prod)    #mu=Mu  #sigma=Sigma        for (d in 1:mm){    mu=alpha+beta*x[d]    dt[d]=mahalanobis(t[d,],mu,Sigma)#as.numeric((t[d,]-mu)%*%solve(Sigma)%*%t(t[d,]-mu))       if (dist == "Normal"){#funk[d]=dnorm(sqrt(dt[d]))        funk[d]=dmvnorm((t[d,]-mu), mean = rep(0, p) , sigma =Sigma)}     if (dist == "Student"){funk[d]=(pi^(-p/2)*nu^(nu/2)*gamma((nu+p)/2))/(gamma(nu/2)*(dt[d]+nu)^((nu+p)/2))}    if (dist == "Slash"){funk[d]=(2*pi)^(-p/2)*(  (nu*2^(nu+(p/2))*gamma( nu+(p/2) )  )/dt[d]^(nu+(p/2)) )*fp1(a=nu+(p/2),b=dt[d]/2)}    if (dist == "Cont"){nu1=nu[1]    gama=nu[2]    #funk[d]=(nu1*dnorm(sqrt(dt[d]),0,(1/sqrt(gama)))+(1-nu1)*dnorm(sqrt(dt[d])))    funk[d]=nu1*dmvnorm((t[d,]-mu), mean = rep(0, p) , sigma =(gama^(-1))*Sigma)+(1-nu1)*dmvnorm((t[d,]-mu), mean = rep(0, p) , sigma =Sigma)}    if(p>1){      vero1[d]=-0.5*log(det(Sigma))+log(funk[d])      if ((dist == "Normal")|| (dist == "Cont")){        vero1[d]=log(funk[d])      }          }else{vero1[d]=log(funk[d])}      }    vero=sum(vero1)  return(vero)}#verohelton(t,Mu,Sigma,0.5,"Student")#verohelton(t,Mu,Sigma,0.5,"Normal")#verohelton(t,Mu,Sigma,0.5,"Slash")#verohelton(t,Mu,Sigma,0.5,"Cont")veroheltonnucont<-function(nu,t,mu,Sigma){    mm=dim(t)[1]  p=dim(t)[2]    eta=matrix(0,mm,p)  epsilon=matrix(0,mm,p)  #at=matrix(0,mm,p)  #Atparte=matrix(0,mm,p)  vero1=matrix(0,mm,1)  dt=matrix(0,mm,1)  funk=matrix(0,mm,1)      #for (j in 1:p) {  #  epsilon[,j]=sqrt(t[,j]/beta[j])-sqrt(beta[j]/t[,j])  #  at[,j]=epsilon[,j]/alpha[j]  #  Atparte[,j]= (t[,j]+beta[j])/(2*alpha[j]*sqrt(beta[j])*sqrt(t[,j]^3))  #}     #At=apply(Atparte,1,prod)    for (d in 1:mm){    #dt[d]=as.numeric(t(t[d,]-mu)%*%solve(sigma)%*%(t[d,]-mu))           nu1=nu    gama=1-nu1       #funk[d]=(nu1*dnorm(sqrt(dt[d]),0,(1/sqrt(gama)))+(1-nu1)*dnorm(sqrt(dt[d])))    funk[d]=nu1*dmvnorm((t[d,]-mu), mean = rep(0, p) , sigma =((gama^(-1))*Sigma))+(1-nu1)*dmvnorm((t[d,]-mu), mean = rep(0, p) , sigma =Sigma)    if(p>1){      vero1[d]=log(funk[d])                }else{vero1[d]=log(funk[d])}      }    vero=sum(vero1)  return(vero)}#veroheltonnucont(0.2,t,Mu,Sigma)veroheltonnusla<-function(nu,t,mu,Sigma){    mm=dim(t)[1]  p=dim(t)[2]    eta=matrix(0,mm,p)  epsilon=matrix(0,mm,p)  #at=matrix(0,mm,p)  #Atparte=matrix(0,mm,p)  vero1=matrix(0,mm,1)  dt=matrix(0,mm,1)  funk=matrix(0,mm,1)      #for (j in 1:p) {  #  epsilon[,j]=sqrt(t[,j]/beta[j])-sqrt(beta[j]/t[,j])  #  at[,j]=epsilon[,j]/alpha[j]  #  Atparte[,j]= (t[,j]+beta[j])/(2*alpha[j]*sqrt(beta[j])*sqrt(t[,j]^3))  #}     #At=apply(Atparte,1,prod)  for (d in 1:mm){    dt[d]=as.numeric((t[d,]-mu)%*%solve(Sigma)%*%t(t[d,]-mu))             funk[d]=(2*pi)^(-p/2)*(  (nu*2^(nu+(p/2))*gamma( nu+(p/2) )  )/dt[d]^(nu+(p/2)) )*fp1(a=nu+(p/2),b=dt[d]/2)        if(p>1){      vero1[d]=-0.5*log(det(Sigma))+log(funk[d])    }else{vero1[d]=log(funk[d])}  }    vero=sum(vero1)  return(vero)}#veroheltonnusla(0.2,t,Mu,Sigma)veroheltonnut<-function(nu,t,alpha,beta,Sigma){    mm=dim(t)[1]  p=dim(t)[2]    eta=matrix(0,mm,p)  epsilon=matrix(0,mm,p)  #at=matrix(0,mm,p)  #Atparte=matrix(0,mm,p)  vero1=matrix(0,mm,1)  dt=matrix(0,mm,1)  funk=matrix(0,mm,1)      #for (j in 1:p) {  #  epsilon[,j]=sqrt(t[,j]/beta[j])-sqrt(beta[j]/t[,j])  #  at[,j]=epsilon[,j]/alpha[j]  #  Atparte[,j]= (t[,j]+beta[j])/(2*alpha[j]*sqrt(beta[j])*sqrt(t[,j]^3))  #}     #At=apply(Atparte,1,prod)    for (d in 1:mm){
    mu=alpha+beta*x[d]    dt[d]=mahalanobis(t[d,],mu,Sigma)          funk[d]=(pi^(-p/2)*nu^(nu/2)*gamma((nu+p)/2))/(gamma(nu/2)*(dt[d]+nu)^((nu+p)/2))        if(p>1){      vero1[d]=-0.5*log(det(Sigma))+log(funk[d])    }else{vero1[d]=log(funk[d])}      }    vero=sum(vero1)  return(vero)}#veroheltonnut(0.2,t,Mu,Sigma)################################################################ Generalized multivariate Birnbaum–Saunders distributions ## and related inferential issues (2013): section 4.1.2##############################################################chuteini<-function(t,dist){    n=dim(t)[1]  p=dim(t)[2]    lb=matrix(rep(0.1,p),p,1)  lu=matrix(rep(10,p),p,1)  epsilon=matrix(0,n,p)  at=matrix(0,n,p)    s=matrix(apply(t,2,mean),1,p)  D=cov(t)    if(dist == "Normal"){    nu=optim(0.5, verohelton, gr=NULL, t=t,mu=s,Sigma=D,dist="Normal", control = list(fnscale = -1), method = "L-BFGS-B", lower = lb, upper = lu)$par  }  if(dist == "Student"){    nu=optim(0.5, veroheltonnut, gr=NULL, t=t,alpha=rep(1,p),beta=rep(1,p),Sigma=D, control = list(fnscale = -1), method = "L-BFGS-B", lower = lb, upper = lu)$par  }  if(dist == "Slash"){    nu=optim(0.5, veroheltonnusla, gr=NULL, t=t,mu=s,Sigma=D, control = list(fnscale = -1), method = "L-BFGS-B", lower = lb, upper = lu)$par  }    if(dist == "Cont"){    #ui <- matrix(c(1, 1, -1, 0, 0, -1), nrow = 3)  # Constraints: x + y >= 1, x >= 0, y >= 0    #ci <- c(1, 0, 0)  # Corresponding constraint values    nu=optim(0.5, veroheltonnucont, gr=NULL, t=t,mu=s,Sigma=D, control = list(fnscale = -1), method = "L-BFGS-B", lower = lb, upper = c(0.9,0.9))$par        #nu=constrOptim(c(0.5, 0.5), veroheltonnucont, gr = NULL, t = t, mu = mu, Sigma = Sigma    #            , control = list(fnscale = -1), method = "L-BFGS-B", lower = lb, upper = c(1, 1), ui =ui, ci = ci)$par        nu=c(nu,1-nu)  }        result = list(mu = s, nu=nu, D=D)  return(result)}#chuteini(t,"Normal")#chuteini(t,"Student")#chuteini(t,"Slash")#chuteini(t,"Cont")################################################################ EM geral##############################################################fp1 <- function(a,b){  cdf<-pgamma(1, shape=a, scale = 1/b)  return(cdf)}Qbeta <- function(t,mu,Sigma,u){  n=dim(t)[1]  p=dim(t)[2]    eta=matrix(0,n,p)  epsilon=matrix(c(0),n,p)  at=matrix(c(0),n,p)        #for (j in 1:p){  #  eta[,j]=beta[j]  #  epsilon[,j]=sqrt(t[,j]/beta[j])-sqrt(beta[j]/t[,j])  #  at[,j]=epsilon[,j]/alpha[j]  #}    auxQbeta=matrix(0,n,1)  dt=matrix(0,n,1)  for (d in 1:n){    dt[d]=as.numeric(as.matrix(t[d,]-mu)%*%solve(Sigma)%*%t(as.matrix((t[d,]-mu))))    auxQbeta[d]=u[d]*dt[d]  }  if(p>1){    Q=-(n/2)*log(det(Sigma))-0.5*sum(auxQbeta)  }else{Q=-0.5*sum(auxQbeta)}  return(Q)}emhelton <- function(t,error,lb,lu,nu,mu,dist){    # t: dados multivariados t=(t1,t2,t3,..., tp): n por p  # alpha=(alpha1,alpha2, alpha3,..., alphap) p por 1  # beta=(beta1,beta2,beta3,...,betap) p por 1  # Sigma: matriz p por p  # error: precisão das estimativas  # lb e lu: valores iniciais para a maximização de beta  #error=0.0001  #dist0="Cont"  chute <- chuteini(t,dist)  #alpha<-chute$alpha  #beta=chute$beta  mu=chute$mu  Sigma=chute$D  nu=chute$nu    n=dim(t)[1]  p=dim(t)[2]      criterio <- 1  cont=0  lkante <- 1    while (criterio > error){        cont=cont+1    epsilon=matrix(c(0),n,p)    at=matrix(c(0),n,p)    dt=matrix(0,n,1)    u=matrix(0,n,1)                #for (j in 1:p){    #  epsilon[,j]=sqrt(t[,j]/beta[j])-sqrt(beta[j]/t[,j])    #  at[,j]=epsilon[,j]/alpha[j]    #}        for (d in 1:n){      dt[d]=as.numeric((t[d,]-mu)%*%solve(Sigma)%*%t(t[d,]-mu))            #ETAPA E            if (dist == "Normal"){u[d]=1}            if (dist == "Student"){u[d]=(nu+p)/(nu+dt[d])}            if (dist == "Slash"){u[d]=(((2*nu)+p)/dt[d])*(fp1(p/2+nu+1,dt[d]/2)/fp1(p/2+nu,dt[d]/2))}            if (dist == "Cont"){nu1=nu[1]      gama=nu[2]      u[d]<-(1-nu1+nu1*(gama^((p+2)/2))*exp((1-gama)*dt[d]/2))/(1-nu1+nu1*(gama^(p/2))*exp((1-gama)*dt[d]/2))      }          }        #ETAPA M             uz=matrix(0,nrow =n,ncol=p)    uzmu=matrix(0,nrow =n,ncol=p*p)    for (d in 1:n) {      uz[d,]=u[d]*t[d,]    }    require(matrixcalc)    mu=(apply(uz,2,sum)/sum(u))    for (d in 1:n) {      uzmu[d,]=t(vec(u[d]*(t[d,]-mu)%*%t(t[d,]-mu)))    }    mu=t(as.matrix(mu))    Sigma=(1/n)*matrix(apply(uzmu,2,sum),p,p)        if(dist == "Student"){      nu=optim(0.5, veroheltonnut, gr=NULL, t=t,alpha=alpha,beta=beta,Sigma=Sigma, control = list(fnscale = -1), method = "L-BFGS-B", lower = lb, upper = lu)$par    }    if(dist == "Slash"){      nu=optim(0.5, veroheltonnusla, gr=NULL, t=t,mu=mu,Sigma=Sigma, control = list(fnscale = -1), method = "L-BFGS-B", lower = lb, upper = lu)$par    }    if(dist == "Cont"){      nu=optim(0.5, veroheltonnucont, gr=NULL, t=t,mu=mu,Sigma=Sigma, control = list(fnscale = -1), method = "L-BFGS-B", lower = c(0.1,0.1), upper = c(0.9,0.9))$par    }            lk=verohelton(t,mu,Sigma,nu,dist)    criterio <- abs((lk/lkante)-1)    lkante <- lk      }     object.out = list(mu=mu, Sigma=Sigma,lk=lk,nu=nu)#,u=u)  return(object.out)}#emhelton(t,0.0001,lb,lu,0.2,Mu,"Normal")#emhelton(t,0.0001,lb,lu,0.2,Mu,"Student")#emhelton(t,0.0001,lb,lu,0.2,Mu,"Slash")#emhelton(t,0.0001,lb,lu,0.2,Mu,"Cont")emheltonnu<-function(t,x,alpha,beta,error,lb,lu,nu,dist){  alpha=rep(1,5)  beta=rep(1,5)  nu=1  dist="Student"  # t: dados multivariados t=(t1,t2,t3,..., tp): n por p  # alpha=(alpha1,alpha2, alpha3,..., alphap) p por 1  # beta=(beta1,beta2,beta3,...,betap) p por 1  # Sigma: matriz p por p  # error: precisão das estimativas  # lb e lu: valores iniciais para a maximização de beta  #dist0="Cont"  chute <- chuteini(t,dist)  nu<-chute$nu    Sigma=chute$D      n=dim(t)[1]  p=dim(t)[2]      criterio <- 1  cont=0  lkante <- 1    while (criterio > error){        cont=cont+1    epsilon=matrix(c(0),n,p)    at=matrix(c(0),n,p)    dt=matrix(0,n,1)    u=matrix(0,n,1)                #for (j in 1:p){    #  epsilon[,j]=sqrt(t[,j]/beta[j])-sqrt(beta[j]/t[,j])    #  at[,j]=epsilon[,j]/alpha[j]    #}        for (d in 1:n){      mu<-alpha+beta*x[d]      dt[d]=mahalanobis(t[d,],mu,Sigma)        #as.numeric((t[d,]-mu)%*%solve(Sigma)%*%t(t[d,]-mu))            #ETAPA E            if (dist == "Normal"){u[d]=1}            if (dist == "Student"){u[d]=(nu+p)/(nu+dt[d])}            if (dist == "Slash"){u[d]=(((2*nu)+p)/dt[d])*(fp1(p/2+nu+1,dt[d]/2)/fp1(p/2+nu,dt[d]/2))}            if (dist == "Cont"){nu1=nu[1]      gama=1-nu1      u[d]<-(1-nu1+nu1*(gama^((p+2)/2))*exp((1-gama)*dt[d]/2))/(1-nu1+nu1*(gama^(p/2))*exp((1-gama)*dt[d]/2))      }          }        #ETAPA M         udd=matrix(0,nrow=n,ncol=1)    uz=matrix(0,nrow =n,ncol=p)    uzmu=matrix(0,nrow =n,ncol=p*p)    tbarra=apply(t,2,mean)    xbarra=mean(x)    for (d in 1:n) {      uz[d,]=u[d]*x[d]*(t[d,]-tbarra)      udd[d,]=u[d]*x[d]*(x[d]-xbarra)    }    require(matrixcalc)    beta=(apply(uz,2,sum)/sum(udd))    alpha=tbarra-beta*xbarra    for (d in 1:n) {      uzmu[d,]=t(vec(u[d]*(t[d,]-(alpha + beta*x[d]))%*%t(t[d,]-(alpha + beta*x[d]))))    }    mu=t(as.matrix(mu))    Sigma=(1/n)*matrix(apply(uzmu,2,sum),p,p)            nu.old=nu            if (dist == "Student"){      nu <- optim(nu.old, veroheltonnut,t=t,Sigma=Sigma,alpha=alpha,beta=beta, gr=NULL, control = list(fnscale = -1), method = "L-BFGS-B", lower = 0.1, upper = 100)$par}        if (dist == "Slash"){      nu <- optim(nu.old, veroheltonnusla,t=t,Sigma=Sigma,mu=mu, gr=NULL, control = list(fnscale = -1), method = "L-BFGS-B", lower =0.1, upper = 100)$par}        if (dist == "Cont"){      nu <- optim(nu.old[1], veroheltonnucont,t=t,Sigma=Sigma,mu=mu, gr=NULL, control = list(fnscale = -1), method = "L-BFGS-B", lower =0.1, upper =0.9)$par      nu=c(nu,1-nu)        }            lk=verohelton(t,alpha,beta,Sigma,nu,dist)    criterio <- abs((lk/lkante)-1)    lkante <- lk        #theta=c(nu,Sigma[upper.tri(Sigma,diag=T)])      }   if(dist=="Student" || dist=="Slash" || dist=="Cont"){    object.out = list(lk=lk,u=u,dt=dt,nu=nu,Sigma=Sigma,alpha=alpha,beta=beta)}else{object.out = list(lk=lk,dt=dt,theta=theta[2:nrow(as.matrix(theta))])}  return(object.out)}#emheltonnu(t,0.0001,lb,lu,0.2,Mu,"Normal")#emheltonnu(t,0.0001,lb,lu,0.2,Mu,"Student")#emheltonnu(t,0.0001,lb,lu,0.2,Mu,"Slash")#emheltonnu(t,0.0001,lb,lu,0.2,"Cont")emheltonnucorto <- function(t,error,lb,lu,nu,dist){    # t: dados multivariados t=(t1,t2,t3,..., tp): n por p  # alpha=(alpha1,alpha2, alpha3,..., alphap) p por 1  # beta=(beta1,beta2,beta3,...,betap) p por 1  # Sigma: matriz p por p  # error: precisão das estimativas  # lb e lu: valores iniciais para a maximização de beta  #dist="Normal"  chute <- chuteini(t,dist)  mu<-mean(chute$mu)%*%matrix(1,ncol=p,nrow=1)  nu<-chute$nu  #alpha<-chute$alpha  #beta=chute$beta  Sigma=chute$D      n=dim(t)[1]  p=dim(t)[2]      criterio <- 1  cont=0  lkante <- 1    while (criterio > error){        cont=cont+1    epsilon=matrix(c(0),n,p)    at=matrix(c(0),n,p)    dt=matrix(0,n,1)    u=matrix(0,n,1)                #for (j in 1:p){    #  epsilon[,j]=sqrt(t[,j]/beta[j])-sqrt(beta[j]/t[,j])    #  at[,j]=epsilon[,j]/alpha[j]    #}        for (d in 1:n){      dt[d]=as.numeric((t[d,]-mu)%*%solve(Sigma)%*%t(t[d,]-mu))            #ETAPA E            if (dist == "Normal"){u[d]=1}            if (dist == "Student"){u[d]=(nu+p)/(nu+dt[d])}            if (dist == "Slash"){u[d]=(((2*nu)+p)/dt[d])*(fp1(p/2+nu+1,dt[d]/2)/fp1(p/2+nu,dt[d]/2))}            if (dist == "Cont"){nu1=nu[1]      gama=1-nu1      u[d]<-(1-nu1+nu1*(gama^((p+2)/2))*exp((1-gama)*dt[d]/2))/(1-nu1+nu1*(gama^(p/2))*exp((1-gama)*dt[d]/2))      }          }        #ETAPA M             uz=matrix(0,nrow =n,ncol=p)    uzmu=matrix(0,nrow =n,ncol=p*p)    for (d in 1:n) {      uz[d,]=u[d]*t[d,]    }    require(matrixcalc)    mu=(matrix(1,ncol=p,nrow=1)%*%solve(Sigma)%*%(apply(uz,2,sum))/(matrix(1,ncol=p,nrow=1)%*%solve(Sigma)%*%matrix(1,ncol = 1,nrow=p)*sum(u)))    mu1=rep(mu,3)    for (d in 1:n) {      if(p==1){uzmu[d,]=unique(as.numeric(t(vec(u[d]*(t[d,]-mu1)%*%t(t[d,]-mu1)))))}else{        uzmu[d,]=t(vec(u[d]*(t[d,]-mu1)%*%t(t[d,]-mu1)))}    }    mu=matrix(mean(mu),ncol=p,nrow=1)    Sigma=(1/n)*matrix(apply(uzmu,2,sum),p,p)            nu.old=nu            if (dist == "Student"){      nu <- optim(nu.old, veroheltonnut,t=t,Sigma=Sigma,mu=mu, gr=NULL, control = list(fnscale = -1), method = "L-BFGS-B", lower = 0.1, upper = 100)$par}        if (dist == "Slash"){      nu <- optim(nu.old, veroheltonnusla,t=t,Sigma=Sigma,mu=mu, gr=NULL, control = list(fnscale = -1), method = "L-BFGS-B", lower =0.1, upper = 100)$par}        if (dist == "Cont"){      nu <- optim(nu.old[1], veroheltonnucont,t=t,Sigma=Sigma,mu=mu, gr=NULL, control = list(fnscale = -1), method = "L-BFGS-B", lower =0.1, upper =0.9)$par      nu=c(nu,1-nu)        }                lk=verohelton(t,mu,Sigma,nu,dist)    criterio <- abs((lk/lkante)-1)    lkante <- lk    theta=c(nu,mu,Sigma[upper.tri(Sigma,diag=T)])      }   if(dist=="Student" || dist=="Slash" || dist=="Cont"){    object.out = list(lk=lk,u=u,dt=dt,theta=theta)}else{object.out = list(lk=lk,dt=dt,theta=theta[2:nrow(as.matrix(theta))])}  return(object.out)}#emheltonnucorto(t,0.0001,lb,lu,0.2,"Normal")#emheltonnucorto(t,0.0001,lb,lu,0.2,"Student")#emheltonnucorto(t,0.0001,lb,lu,0.2,"Slash")#emheltonnucorto(t,0.0001,lb,lu,0.2,"Cont")################################################################ Desvios##############################################################veronormal <- function(theta,t){        require(stats)  mm=dim(t)[1]  p=dim(t)[2]  ##### contexto bivariado - alterar para p diferente de 2!!!!  #nu mu sigma  mu=matrix(theta[1:(p)],1,p)  #nu=theta[1]  I<-diag(p)  I[upper.tri(I,diag =T)]<-theta[(p+1):(p+(p*(p-1)/2)+p)]  I[lower.tri(I,diag=F)]<-I[upper.tri(I,diag =F)]  Sigma=I#matrix(theta[(p+2):(1+p+(p*(p-1)/2)+p)],p,p)    epsilon=matrix(0,mm,p)  at=matrix(0,mm,p)  Atparte=matrix(0,mm,p)  vero1=matrix(0,mm,1)  dt=matrix(0,mm,1)  funk=matrix(0,mm,1)          #for (j in 1:p) {  #  epsilon[,j]=sqrt(t[,j]/as.numeric(beta[j]))-sqrt(as.numeric(beta[j])/t[,j])  #  at[,j]=epsilon[,j]/as.numeric(alpha[j])  #  Atparte[,j]= (t[,j]+as.numeric(beta[j]))/(2*as.numeric(alpha[j])*sqrt(as.numeric(beta[j]))*sqrt(t[,j]^3))  #}     #At=apply(Atparte,1,prod)      for (d in 1:mm){    dt[d]=as.numeric((t[d,]-mu)%*%solve(Sigma)%*%t(t[d,]-mu))    funk[d]=dmvnorm((t[d,]-mu), mean = rep(0, p) , sigma =Sigma)    if(p>1){      vero1[d]=log(funk[d])    }else{vero1[d]=log(funk[d])}#-0.5*log(det(Sigma))  }    vero=sum(vero1)  return(vero)}#theta=emheltonnu(t,0.0001,lb,lu,0.2,Mu,"Normal")$theta#veronormal(theta,t)verot <- function(theta,t){        require(stats)  mm=dim(t)[1]  p=dim(t)[2]  ##### contexto bivariado - alterar para p diferente de 2!!!!  #nu mu sigma  mu=matrix(theta[2:(1+p)],1,p)  nu=theta[1]  I<-diag(p)  I[upper.tri(I,diag =T)]<-theta[(p+2):(1+p+(p*(p-1)/2)+p)]  I[lower.tri(I,diag=F)]<-I[upper.tri(I,diag =F)]  Sigma=I#matrix(theta[(p+2):(1+p+(p*(p-1)/2)+p)],p,p)    epsilon=matrix(0,mm,p)  at=matrix(0,mm,p)  Atparte=matrix(0,mm,p)  vero1=matrix(0,mm,1)  dt=matrix(0,mm,1)  funk=matrix(0,mm,1)              for (d in 1:mm){    dt[d]=as.numeric((t[d,]-mu)%*%solve(Sigma)%*%t(t[d,]-mu))    funk[d]=(pi^(-p/2)*nu^(nu/2)*gamma((nu+p)/2))/(gamma(nu/2)*(dt[d]+nu)^((nu+p)/2))    if(p>1){      vero1[d]=-0.5*log(det(Sigma))+log(funk[d])    }else{vero1[d]=log(funk[d])}  }  vero=sum(vero1)  return(vero)}#theta=emheltonnu(t,0.0001,lb,lu,0.2,Mu,"Student")$theta#verot(theta,t)verotnu <- function(theta,t){        require(stats)  mm=dim(t)[1]  p=dim(t)[2]  ##### contexto bivariado - alterar para p diferente de 2!!!!  #nu mu sigma  mu=matrix(theta[2:(1+p)],1,p)  nu=theta[1]  I<-diag(p)  I[upper.tri(I,diag =T)]<-theta[(p+2):(1+p+(p*(p-1)/2)+p)]  I[lower.tri(I,diag=F)]<-I[upper.tri(I,diag =F)]  Sigma=I#matrix(theta[(p+2):(1+p+(p*(p-1)/2)+p)],p,p)    epsilon=matrix(0,mm,p)  at=matrix(0,mm,p)  Atparte=matrix(0,mm,p)  vero1=matrix(0,mm,1)  dt=matrix(0,mm,1)  funk=matrix(0,mm,1)          #for (j in 1:p) {  #  epsilon[,j]=sqrt(t[,j]/beta[j])-sqrt(beta[j]/t[,j])  #  at[,j]=epsilon[,j]/alpha[j]  #  Atparte[,j]= (t[,j]+beta[j])/(2*alpha[j]*sqrt(beta[j])*sqrt(t[,j]^3))  #}     #At=apply(Atparte,1,prod)    for (d in 1:mm){    dt[d]=as.numeric((t[d,]-mu)%*%solve(Sigma)%*%t(t[d,]-mu))        funk[d]=(pi^(-p/2)*nu^(nu/2)*gamma((nu+p)/2))/(gamma(nu/2)*(dt[d]+nu)^((nu+p)/2))      if(p>1){      vero1[d]=-0.5*log(det(Sigma))+log(funk[d])    }else{vero1[d]=log(funk[d])}  }    vero=sum(vero1)  return(vero)}#verotnu(theta,t)veroslanu <- function(theta,t){      require(stats)  mm=dim(t)[1]  p=dim(t)[2]  ##### contexto bivariado - alterar para p diferente de 2!!!!  #nu mu sigma  mu=matrix(theta[2:(1+p)],1,p)  nu=theta[1]  I<-diag(p)  I[upper.tri(I,diag =T)]<-theta[(p+2):(1+p+(p*(p-1)/2)+p)]  I[lower.tri(I,diag=F)]<-I[upper.tri(I,diag =F)]  Sigma=I#matrix(theta[(p+2):(1+p+(p*(p-1)/2)+p)],p,p)    epsilon=matrix(0,mm,p)  at=matrix(0,mm,p)  Atparte=matrix(0,mm,p)  vero1=matrix(0,mm,1)  dt=matrix(0,mm,1)  funk=matrix(0,mm,1)              for (d in 1:mm){    dt[d]=as.numeric((t[d,]-mu)%*%solve(Sigma)%*%t(t[d,]-mu))    funk[d]=(2*pi)^(-p/2)*(  (nu*2^(nu+(p/2))*gamma( nu+(p/2) )  )/dt[d]^(nu+(p/2)) )*fp1(a=nu+(p/2),b=dt[d]/2)    if(p>1){      vero1[d]=-0.5*log(det(Sigma))+log(funk[d])    }else{vero1[d]=+log(funk[d])}  }    vero=sum(vero1)  return(vero)}#theta=emheltonnu(t,0.0001,lb,lu,0.2,Mu,"Slash")$theta#veroslanu(theta,t)verocontnu<-function(theta,t){        require(stats)  mm=dim(t)[1]  p=dim(t)[2]  ##### contexto bivariado - alterar para p diferente de 2!!!!  #nu mu sigma  mu=matrix(theta[3:(2+p)],1,p)  nu1=theta[1]  gama=theta[2]  I<-diag(p)  I[upper.tri(I,diag =T)]<-theta[(p+3):(2+p+(p*(p-1)/2)+p)]  I[lower.tri(I,diag=F)]<-I[upper.tri(I,diag =F)]  Sigma=I#matrix(theta[(p+2):(1+p+(p*(p-1)/2)+p)],p,p)    epsilon=matrix(0,mm,p)  at=matrix(0,mm,p)  Atparte=matrix(0,mm,p)  vero1=matrix(0,mm,1)  dt=matrix(0,mm,1)  funk=matrix(0,mm,1)      for (d in 1:mm){    #dt[d]=as.numeric(t(t[d,]-mu)%*%solve(sigma)%*%(t[d,]-mu))    #funk[d]=(nu1*dnorm(sqrt(dt[d]),0,1/sqrt(gama))+(1-nu1)*dnorm(sqrt(dt[d])))    funk[d]=nu1*dmvnorm((t[d,]-mu), mean = rep(0, p) , sigma =(gama^(-1))*Sigma)+(gama)*dmvnorm((t[d,]-mu), mean = rep(0, p) , sigma =Sigma)    if(p>1){      vero1[d]=log(funk[d])    }else{vero1[d]=log(funk[d])}  }    vero=sum(vero1)  return(vero)}#theta=emheltonnu(t,0.0001,lb,lu,0.2,Mu,"Cont")$theta#verocontnu(theta,t)desviosgrad<-function(theta,dados,nuaux,dist){    ### Erros-padrão utilizando a função grad()    n=dim(dados)[1]  p=dim(dados)[2]            i <- 1  while(i < (n+1)){                            if (dist == "Normal"){      mat1 <- grad(veronormal, theta, method="Richardson",t=matrix(dados[i,],1,p))}        if (dist == "Student"){      mat1 <- grad(verot, theta, method="Richardson",t=matrix(dados[i,],1,p),nu=nuaux)}        if (dist == "Slash"){      mat1 <- grad(verosla, theta, method="Richardson",t=matrix(dados[i,],1,p),nu=nuaux)}        if (dist == "Cont"){      mat1 <- grad(verocont, theta, method="Richardson",t=matrix(dados[i,],1,p),nu=nuaux)}        mat <- mat1%*%t(mat1)        if(i == 1){      X <- mat    }else{      X <- X + mat    }        i <- i + 1  }    errosGrad2 <- round(sqrt(diag(solve(X))), 6)  return(errosGrad2)}desviosgradnu<-function(theta,dados,dist){    ### Erros-padrão utilizando a função grad()  #dados=t  n=dim(dados)[1]  p=dim(dados)[2]  #dist="Cont"          i <- 1  while(i < (n+1)){                            if (dist == "Normal"){      mat1 <- grad(veronormal, theta, method="Richardson",t=matrix(dados[i,],1,p))}        if (dist == "Student"){      mat1 <- grad(verotnu, theta, method="Richardson",t=matrix(dados[i,],1,p))}        if (dist == "Slash"){      mat1 <- grad(veroslanu, theta, method="Richardson",t=matrix(dados[i,],1,p))}        if (dist == "Cont"){      mat1 <- grad(verocontnu, theta, method="Richardson",t=matrix(dados[i,],1,p))}        mat <- mat1%*%t(mat1)        if(i == 1){      X <- mat    }else{      X <- X + mat    }        i <- i + 1  }  errosGrad2 <- round(sqrt(diag(solve(X))), nrow(as.matrix(theta)))  return(errosGrad2)}#theta=emheltonnu(t,0.0001,lb,lu,nu,"Normal")$theta#desviosgradnu(theta,t,"Normal")#theta=emheltonnu(t,0.0001,lb,lu,nu,Mu,"Student")$theta#desviosgradnu(theta,t,"Student")#theta=emheltonnu(t,0.0001,lb,lu,nu,Mu,"Slash")$theta#desviosgradnu(theta,t,"Slash")#theta=emheltonnu(t,0.0001,lb,lu,nu,Mu,"Cont")$theta#desviosgradnu(theta,t,"Cont")################################################################ Mahalanobis##############################################################mahacap2 <- function(t,beta,alpha,Sigma){    n=dim(t)[1]  p=dim(t)[2]        epsilon=matrix(c(0),n,p)  at=matrix(c(0),n,p)  dt=matrix(0,n,1)      n=dim(t)[1]  p=dim(t)[2]      epsilon=matrix(c(0),n,p)  at=matrix(c(0),n,p)          for (j in 1:p){    epsilon[,j]=sqrt(t[,j]/beta[j])-sqrt(beta[j]/t[,j])    at[,j]=epsilon[,j]/alpha[j]  }  h  for (d in 1:n){    dt[d]=as.numeric(t(t[d,]-mu)%*%solve(sigma)%*%(t[d,]-mu))  }    return(as.vector(dt))  }